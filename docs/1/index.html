
console.log("========<

console.log(sceneCamera.projectionMatrixInverse)
html>
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
          name="viewport">
    <meta content="ie=edge" http-equiv="X-UA-Compatible">
    <title>sketch: 1</title>
    
    <style type="text/css">
        html, body {
            background-color: black;
        }
        #js-wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #js-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>

<div id="js-wrapper">
    <canvas id="js-canvas"></canvas>
</div>

<script src="https://unpkg.com/three@0.142.0/build/three.min.js"></script>

<script>
    // -----------------------------------------------------------------------------
    // ref:
    // https://threejs.org/examples/webgl2_multiple_rendertargets.html
    // https://github.com/mrdoob/three.js/blob/master/src/renderers/WebGLMultipleRenderTargets.js
    // https://threejs.org/examples/webgl_depth_texture.html
    // https://enginetrouble.net/2016/10/reconstructing-world-position-from-depth-2016.html
    // -----------------------------------------------------------------------------

    class GBufferRenderTargets extends THREE.WebGLRenderTarget {

        constructor( width, height) {

            super( width, height);

            this.isWebGLMultipleRenderTargets = true;

            const texture = this.texture;

            this.texture = [];

            this.texture[0] = texture.clone();
            this.texture[0].isRenderTargetTexture = true;

            this.texture[1] = texture.clone();
            this.texture[1].isRenderTargetTexture = true;

            // this.texture[2] = texture.clone();
            // this.texture[2].isRenderTargetTexture = true;
            
            // console.log(THREE)
        }

        setSize( width, height, depth = 1 ) {

            if ( this.width !== width || this.height !== height || this.depth !== depth ) {

                this.width = width;
                this.height = height;
                this.depth = depth;

                for ( let i = 0, il = this.texture.length; i < il; i ++ ) {

                    this.texture[ i ].image.width = width;
                    this.texture[ i ].image.height = height;
                    this.texture[ i ].image.depth = depth;

                }

                this.dispose();

            }

            this.viewport.set( 0, 0, width, height );
            this.scissor.set( 0, 0, width, height );

            return this;

        }

        copy( source ) {

            this.dispose();

            this.width = source.width;
            this.height = source.height;
            this.depth = source.depth;

            this.viewport.set( 0, 0, this.width, this.height );
            this.scissor.set( 0, 0, this.width, this.height );

            this.depthBuffer = source.depthBuffer;
            this.stencilBuffer = source.stencilBuffer;

            if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

            this.texture.length = 0;

            for ( let i = 0, il = source.texture.length; i < il; i ++ ) {

                this.texture[ i ] = source.texture[ i ].clone();
                this.texture[ i ].isRenderTargetTexture = true;

            }

            return this;

        }

    }
    
    
    const gbufferVertexShaderText = `
in vec3 position;
in vec3 normal;
in vec2 uv;
out vec3 vNormal;
out vec2 vUv;
// out vec3 vWorldPosition;
uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;
void main() {
    vUv = uv;
    vec4 worldPosition = modelMatrix * vec4(position, 1.);
    vec4 viewPosition = viewMatrix * worldPosition;
    vec3 transformedNormal = normalMatrix * normal;
    vNormal = normalize(transformedNormal);
    // vWorldPosition = worldPosition.xyz;
    gl_Position = projectionMatrix * viewPosition;
}
`;
    const gbufferFragmentShaderText = `
precision highp float;
precision highp int;
layout(location = 0) out vec4 gColor;
layout(location = 1) out vec4 gNormal;
// layout(location = 2) out vec4 gWorldPosition;
in vec3 vNormal;
in vec2 vUv;
// in vec3 vWorldPosition;
void main() {
    gColor = vec4(1, 1, 1, 1);
    vec3 normal = (normalize(vNormal) + 1.) * .5;
    gNormal = vec4(normal , 1.);
    // gWorldPosition = vec4(vWorldPosition, 1.);
}
`;
    const renderVertexShaderText = `
in vec3 position;
in vec2 uv;
out vec2 vUv;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
}
`;
    const renderFragmentShaderText = `
precision highp float;
precision highp int;

#include <packing>

// float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
//   return ( viewZ + near ) / ( near - far );
// }
// 
// float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
//   return ( near * far ) / ( ( far - near ) * invClipZ - far );
// }

layout(location = 0) out vec4 outColor;

in vec2 vUv;

struct Surface {
    vec3 diffuse;
    vec3 normal;
    vec3 worldPosition;
};

struct PointLight {
    vec3 position;
    float intensity;
    float distance;
    vec3 color;
};

struct Camera {
    vec3 position;
};

uniform sampler2D uDiffuse;
uniform sampler2D uNormal;
uniform sampler2D uDepth;
uniform Camera uCamera;
// uniform sampler2D uWorldPosition;
uniform PointLight[1] uPointLights;
uniform float uCameraNear;
uniform float uCameraFar;
uniform mat4 uInverseViewMatrix;
uniform mat4 uInverseProjectionMatrix;

float readDepth( sampler2D depthSampler, vec2 coord ) {
    float fragCoordZ = texture( depthSampler, coord ).x;
    float viewZ = perspectiveDepthToViewZ( fragCoordZ, uCameraNear, uCameraFar );
    return viewZToOrthographicDepth( viewZ, uCameraNear, uCameraFar );
}

vec3 reconstructWorldPositionFromDepth(vec2 uv, float depth)
{
    float d = depth * 2. - 1.;
    // d = depth;
    vec4 projectedPosition = vec4(uv.xy * 2. - 1., d, 1.);
    vec4 viewSpacePosition = uInverseProjectionMatrix * projectedPosition;
    viewSpacePosition.xyz /= viewSpacePosition.w;
    vec4 worldSpacePosition = uInverseViewMatrix * viewSpacePosition;
    // worldSpacePosition.xyz / worldSpacePosition.w;
    // vec3 p = worldSpacePosition.xyz * vec3(1., 1., -1.);
    vec3 p = worldSpacePosition.xyz;
    p.z = p.z * -1. - 1.;
    return p;
    // return worldSpacePosition.xyz;
}

vec3 calcPointLight(PointLight pointLight, Surface surface, Camera camera) {
    // common
    vec3 rawPtoL = pointLight.position - surface.worldPosition;
    vec3 rawPtoE = camera.position - surface.worldPosition;
    vec3 PtoL = normalize(rawPtoL);
    vec3 PtoE = normalize(rawPtoE);
    vec3 HalfV = normalize(PtoL + PtoE);
    vec3 reflectV = reflect(-PtoL, surface.normal);
    float distPtoL = length(rawPtoL);
    float attenuation = pointLight.intensity / (distPtoL * distPtoL);
    float angle = dot(surface.normal, PtoL);
    
    // diffuse
    vec3 diffuseColor = vec3(0.);
    if(angle > 0.)
    {
        float diffuseRate = clamp(0., 1., dot(surface.normal, PtoL));
        diffuseColor = surface.diffuse * pointLight.color * diffuseRate * attenuation;
    }
    
    // specular
    vec3 specularColor = vec3(0.);
    if(angle > 0.)
    {
        // 1: use reflect V
        // float specularRate = clamp(0., 1., dot(PtoE, reflectV));
        // 2: use half V
        float specularRate = max(0., dot(surface.normal, HalfV));
        float specularPower = 64.;
        float specular = pow(specularRate, specularPower);
        specularColor = vec3(specular) * pointLight.color * attenuation;
    }
    // result
    vec3 resultColor = diffuseColor + specularColor;
    // resultColor = vec3(dot(surface.normal, vec3(1., 0., 0.)));
    resultColor = vec3(dot(surface.normal, PtoL)) * surface.diffuse;
    return resultColor;
}


void main() {
    vec3 diffuse = texture(uDiffuse, vUv).rgb;
    vec3 normal = texture(uNormal, vUv).rgb * 2. - 1.;
    normal = normalize(normal);
    // float depth = readDepth(uDepth, vUv);
    float depth = texture(uDepth, vUv).x;
    vec3 worldPosition = reconstructWorldPositionFromDepth(vUv, depth);
    Surface surface = Surface(diffuse, normal, worldPosition);
    
    Camera camera = Camera(uCamera.position);
    
    vec3 color = vec3(0.);
    for(int i = 0; i < 1; i++)
    {
        PointLight pointLight = uPointLights[i];
        color += calcPointLight(pointLight, surface, camera);
    }
    outColor.rgb = color;
    outColor.a = 1.;
    // outColor.rgb = normal;
    // outColor.rgb = vec3(depth);
    outColor.rgb = worldPosition * diffuse;
    outColor.rgb = vec3(worldPosition.z) * diffuse;
    // outColor.rgb = vec3(worldPosition.xy, -worldPosition.z * 1.) * diffuse;
    // outColor.rgb = vec3(sign(worldPosition.z)) * diffuse;
    // outColor.rgb = mix(diffuse, normal, step(0.5, vUv.x));
    // outColor.a = 1.;
}
`;
    const wrapperElement = document.getElementById("js-wrapper");
    const canvasElement = document.getElementById("js-canvas");

    const ratio = Math.min(window.devicePixelRatio, 1.5);

    const renderer = new THREE.WebGLRenderer({ canvas: canvasElement });
    renderer.setPixelRatio(ratio);

    
    // const renderTarget = new GBufferRenderTargets(1, 1);
    const renderTarget = new THREE.WebGLMultipleRenderTargets(1, 1, 2);
    renderTarget.texture.forEach(texture => {
        texture.minFilter = THREE.NearestFilter;
        texture.magFilter = THREE.NearestFilter;
    });
    renderTarget.texture[0].name = "diffuse";
    renderTarget.texture[1].name = "normal";
    // renderTarget.texture[2].name = "worldPosition";
    
    renderTarget.depthTexture = new THREE.DepthTexture();
    
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    const sceneCamera = new THREE.PerspectiveCamera(60, 1, 0.1, 5);
    
    let width, height;
    
    const mesh = new THREE.Mesh(
        // new THREE.BoxGeometry(1, 1, 1),
        new THREE.SphereGeometry(1, 32, 32),
        // new THREE.TorusKnotGeometry( 1, 0.3, 128, 32 ),
        // new THREE.TorusGeometry( 1, 0.3, 32, 32 ),
        new THREE.RawShaderMaterial({
            vertexShader: gbufferVertexShaderText,
            fragmentShader: gbufferFragmentShaderText,
            uniforms: {},
            glslVersion: THREE.GLSL3
        })
    );
    console.log(mesh)
    
    scene.add(mesh);

    sceneCamera.position.copy(new THREE.Vector3(5, 0, 0))
    sceneCamera.lookAt(mesh.position);
    
    const lightProps = new THREE.Object3D();
    lightProps.add(new THREE.Mesh(
        new THREE.SphereGeometry(0.1, 8, 8),
        new THREE.RawShaderMaterial({
            vertexShader: gbufferVertexShaderText,
            fragmentShader: gbufferFragmentShaderText,
            uniforms: {},
        }),
    ));
    lightProps.add(new THREE.PointLight(0xff0000, 100, 100));
    lightProps.position.copy(new THREE.Vector3(5, 0, 0))
    scene.add(lightProps);

    const postprocessScene = new THREE.Scene();
    const postprocessCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    
    const postprocessMaterial = new THREE.RawShaderMaterial({
        vertexShader: renderVertexShaderText,
        fragmentShader: renderFragmentShaderText,
        uniforms: {
            uDiffuse: {
                value: renderTarget.texture[0]
            },
            uNormal: {
                value: renderTarget.texture[1]
            },
            uDepth: {
                value: renderTarget.depthTexture,
            },
            uCameraNear: {
                value: 0,
            },
            uCameraFar: {
                value: 1
            },
            uInverseViewMatrix: {
                value: new THREE.Matrix4()
            },
            uInverseProjectionMatrix: {
                value: new THREE.Matrix4()
            },
            // uWorldPosition: {
            //     value: renderTarget.texture[2]
            // },
            uPointLights: {
                value: []
            },
            uCamera: {
                value: {}
            }
        },
        glslVersion: THREE.GLSL3
    });
    
    const postprocessPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(2, 2),
        postprocessMaterial
    );
    
    postprocessScene.add(postprocessPlane);
    
    const setSize = () => {
        width = wrapperElement.offsetWidth;
        height = wrapperElement.offsetHeight;
        sceneCamera.aspect = width / height;
        sceneCamera.updateProjectionMatrix();
        renderer.setSize(width, height);
        renderTarget.setSize(width * ratio, height * ratio);
    }
    
    const tick = (time) => {
        // mesh.rotation.x = 90;
        // mesh.rotation.y = 0.0009;
        // mesh.rotation.z = 0.001;
        // mesh.rotation.x = time * 0.0008;
        mesh.rotation.y = time * 0.0002;
        // mesh.rotation.z = time * 0.001;
       
        renderTarget.samples = 3;

        // const inverseViewProjectionMatrix = new THREE.Matrix4().multiplyMatrices(sceneCamera.projectionMatrixInverse, sceneCamera.matrixWorldInverse);
        const inverseViewProjectionMatrix = new THREE.Matrix4().multiplyMatrices(sceneCamera.matrixWorldInverse, sceneCamera.projectionMatrixInverse);
        
        const pointLights = [];

        scene.traverse(obj => {
            if(obj.isPointLight) {
                pointLights.push({
                    color: obj.color,
                    intensity: obj.intensity,
                    distance: obj.distance,
                    position: obj.getWorldPosition(new THREE.Vector3())
                });
            }
        });

        postprocessMaterial.uniforms.uCameraNear.value = sceneCamera.near;
        postprocessMaterial.uniforms.uCameraFar.value = sceneCamera.far;
        postprocessMaterial.uniforms.uInverseViewMatrix.value = sceneCamera.matrixWorldInverse;
        postprocessMaterial.uniforms.uInverseProjectionMatrix.value = sceneCamera.projectionMatrixInverse;
        postprocessMaterial.uniforms.uPointLights.value = pointLights;
        postprocessMaterial.uniforms.uCamera.value = {
            position: sceneCamera.getWorldPosition(new THREE.Vector3())
        }

        // console.log("========")
        // console.log(sceneCamera.matrixWorldInverse)
        // console.log(sceneCamera.projectionMatrixInverse)
        
        
        renderer.setRenderTarget(renderTarget);
        renderer.render(scene, sceneCamera);

        renderer.setRenderTarget(null);
        renderer.render(postprocessScene, postprocessCamera);

        requestAnimationFrame(tick);
    }
   
    setSize();
    window.addEventListener('resize', () => setSize());
    
    requestAnimationFrame(tick);
</script>

</body>
</html>